This is a Bridging Challenge React Native project.
Getting started
	1	The React Native (JavaScript) Side
// App.js (simplified)
import { NativeModules, TouchableOpacity, Text } from 'react-native';

const { AlertModule } = NativeModules; // (1) Get a reference to our native module

const App = () => {
  const handlePress = () => {
    // (2) Call the exposed native method
    if (AlertModule && AlertModule.showNativeAlert) {
      AlertModule.showNativeAlert("Hello from Kotlin!"); // (3) Pass data to native
    }
  };

  return (
    <TouchableOpacity onPress={handlePress}> // (4) User presses button
      <Text>Show Native Alert</Text>
    </TouchableOpacity>
  );
};
What happens here:
a) Const { AlertModule } = NativeModules;
When your react native app starts, it initializes a bridge. Part of this initialization involves discovering all the Native Modules that have been registered on the Native side (will be done on the next steps) Native Modules is a javascript Object that holds references to all these discovered modules.By destructuring AlertModule form NativeModule , you are getting a js object that represents your native Koltin module.
AlertModule.ShowNativeAlert('Hello from Koltin);
This is the magic line!
	•	The javascript code calls a method (showNativeAlert) on the AlertModule object.
	•	Since the AlertModule is a bridging Module , this isn’t a regular js function call. Instead, React Native’s javascript bridge intercepts this call.
	•	The string "Hello from Koltin" is passed as an argument across the bridge.
3) Android/Koltin side - receiving the call
// AlertModule.kt (simplified)
package com.mykotlinalertapp // Your package name

import com.facebook.react.bridge.ReactApplicationContext
import com.facebook.react.bridge.ReactContextBaseJavaModule
import com.facebook.react.bridge.ReactMethod
import android.widget.Toast

class AlertModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {

    override fun getName(): String {
        return "AlertModule" // (A) This name matches the JS NativeModules.AlertModule
    }

    @ReactMethod // (B) This annotation makes the method callable from JS
    fun showNativeAlert(message: String) { // (C) Method signature matches JS call
        // (D) Execute native Android code
        Toast.makeText(reactApplicationContext, message, Toast.LENGTH_LONG).show()
    }
}
What happens here:
A. override fun getName(): String { return "AlertModule" }: This function is crucial. When React Native starts up, it asks all registered native modules for their names. This is how the NativeModules JavaScript object knows to create a property named AlertModule that points to this specific Kotlin class.
B. @ReactMethod: This annotation is like a public signpost for the JavaScript Bridge. It tells React Native, “Hey, this showNativeAlert method can be called directly from JavaScript!” Without this annotation, the method would be invisible to your React Native code.
C. fun showNativeAlert(message: String): When the message arrives from the JavaScript Bridge, the native side looks for a method with the name showNativeAlert and the correct argument types (a String in this case). It then executes this Kotlin function.
D. Toast.makeText(reactApplicationContext, message, Toast.LENGTH_LONG).show(): This is standard Android Kotlin code. It takes the message string that was passed from JavaScript and uses the Toast API to display a small, native alert on the Android device’s screen.
4. The Native Module Registration
class MyAlertPackage : ReactPackage {
    override fun createNativeModules(reactContext: ReactApplicationContext): List<NativeModule> {
        return listOf(AlertModule(reactContext)) // (E) Add your module to the list
    }
    // ... other methods
}```


```js
// MainApplication.java (simplified)
public class MainApplication extends Application implements ReactApplication {
    @Override
    protected List<ReactPackage> getPackages() {
        List<ReactPackage> packages = new PackageList(this).getPackages();
        packages.add(new MyAlertPackage()); // (F) Register your package here
        return packages;
    }
    // ... other methods
}
What happens here:
E. MyAlertPackage.createNativeModules(): When React Native is initializing its native modules, it calls this method on every ReactPackage you’ve registered. You return a list containing an instance of your AlertModule. This is how AlertModule becomes known to the React Native runtime.
F. MainApplication.getPackages(): This is the very first place where your MyAlertPackage gets plugged into the React Native system on Android. When the MainApplication (which is the entry point of your Android app) starts, it builds a list of all ReactPackages. By adding new MyAlertPackage() to this list, you ensure that MyAlertPackage is discovered, and in turn, your AlertModule is registered.
In Summary: The Journey
JavaScript (App.js): You call AlertModule.showNativeAlert("…").
JS Bridge: Intercepts the call, packages it, and sends it to the native side.
Android (MainApplication.java -> MyAlertPackage.kt): The app’s startup registers MyAlertPackage, which contains AlertModule.
Android (AlertModule.kt): The native side receives the message, finds the showNativeAlert method (thanks to @ReactMethod and getName()), and executes it.
Native Android System: The Toast.makeText().show() command displays the alert on the screen.
This entire process happens very quickly, making it seem like a direct call, but it’s the bridge and the module registration that make this cross-language communication possible!
